---
layout: post
title: 코딩테스트 낙서장2
date: 2022-07-03 19:56 +0000
last_modified_at: 2022-07-03 19:56:19 +0000
tags: [코딩테스트]
toc:  true
---

지난 한 주 의문의 잠수를 타면서 뇌가 깨끗해졌습니다. 그로 인해 주요 개념들을 다시 복습하고자 글을 새로 작성했습니다. 이 글에는 주요 개념만 간단하게 채워나갈 예정입니다.<br><br>


## 서로소 집합 알고리즘<br>
- 두 집합이 서로소 관계인 경우 각 집합이 어떤 원소를 공통으로 가지고 있는지 확인할 수 있다. 이를 통해 어떤 노드의 부모 노드(연결된 노드 중 가장 작은 노드)가 같은지를 확인할 수 있다.

```python
# 서로소 집합 알고리즘을 이용한 사이클 판별
def find_parent(parent, x):
    if parent[x] != x:
        parent[x] = find_parent(parent, parent[x])
    return parent[x]

def union_parent(parent, a, b):
    a = find_parent(parent, a)
    b = find_parent(parent, b)

    if a < b:
        parent[b] = a
    else:
        parent[a] = b

v, e = map(int, input().split())
parent = [0] * (v)

for i in range(v):
    parent[i] = i

iscycle = False
for i in range(e):
    a, b = map(int, input().split())
    a-=1
    b-=1

    if find_parent(parent, a) == find_parent(parent, b):
        iscycle = True
        break
    union_parent(parent, a, b)

if iscycle:
    print("CYCLE")
for i in range(v):
    print(parent[i], end=' ')

```

## 크루스칼 알고리즘<br>
- 최소한의 비용으로 신장 트리를 찾을 때 사용한다.

```python
# 크루스칼 알고리즘
def find_parent(parent, x):
    if parent[x] != x:
        parent[x] = find_parent(parent, parent[x])
    return parent[x]

def union_parent(parent, a, b):
    a = find_parent(parent, a)
    b = find_parent(parent, b)

    if a < b:
        parent[b] = a
    else:
        parent[a] = b

v, e = map(int, input().split())
parent = [i for i in range(v)]

edges = []
answer = 0

for _ in range(e):
    a, b, w = map(int, input().split())
    edges.append((w, a-1, b-1))

# 최소 비용부터, 사이클이 생기지 않게 하여, MST를 만들기 위함
edges.sort()

for edge in edges:
    w, s, e = edge

    if find_parent(parent, s) != find_parent(parent, e):
        union_parent(parent, s, e)
        answer += w

print(answer)

```

## 위상 정렬(Topology Sort)<br>
- 위상 정렬은 방향 그래프의 모든 노드를 방향성에 거스르지 않도록 순서대로 나열하는 것이다.

```python
from collections import deque

# 위상 정렬
v, e = map(int, input().split())
indegree = [0] * v

graph = [[] for _ in range(v)]

for _ in range(e):
    a, b = map(int, input().split())
    graph[a-1].append(b-1)
    indegree[b-1] += 1

def topology_sort():
    result = []
    q = deque()

    for i in range(v):
        if indegree[i] == 0:
            q.append(i)
    
    while q:
        cur = q.popleft()
        result.append(cur)

        for i in graph[cur]:
            indegree[i] -= 1
            if indegree[i] == 0:
                q.append(i)
    
    for i in result:
        print(i, end=' ')

topology_sort()

```