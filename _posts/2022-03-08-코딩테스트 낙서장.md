---
layout: post
title: 코딩테스트 낙서장
date: 2022-03-08 18:24 +0900
last_modified_at: 2022-03-09 23:04:46 +0900
tags: [코딩테스트, Python]
toc:  true
---

원래 C++로 준비했었으나, 새로운 마음으로 준비하기 위해 Python으로 갈아탔습니다.<br>
코딩테스트 준비 과정에서 문법적, 테크닉적으로 필요하겠다 싶은 것들을 기록하는 글입니다.<br><br>

## 이차원 리스트
```python
# 0으로 초기화된 N*M 리스트 선언
lst = [
    [0 for _ in range(M)]
    for _ in range(N)
]
```

## input() -> sys.stdin.readline()<br>
- ``sys.stdin.readline()``의 입력 처리 속도가 더 빠릅니다.
```python
import sys
n = int(sys.stdin.readline())
```

## map<br>
- 동시에 여러 값을 입력받기 위해 사용합니다.
```python
x, y = tuple(map(int, input().split())) # x, y
lst = map(int, input().split()) # lst
lst2 = map(int, sys.stdin.readline().split())
# sys.stdin.readline().strip(): readline()은 문자열 뒤에 개행문자가 붙는데, 이를 제거하는 함수이다.
```

## 최빈값 구하기<br>
```python
from collections import Counter
...
mod = Counter(lst).most_common(n) # n 생략시 1
# [(idx1, mod1), (idx2, mod2)] 꼴로 return 됨.
```

## 문자열<->리스트<br>
- 문자열에 sort함수를 사용하는 등의 경우에 사용합니다.
```python
import sys

N = sys.stdin.readline()
temp = list(N)
temp.sort(reverse=True)
N = ''.join(temp)

print(N)

```

## 객체 리스트 정렬시 다중 조건 적용하기<br>
```python
C.sort(key=lambda c: (c.x, c.y))
'''
x와 y를 멤버 변수로 가지는 Coordinate 클래스가 담긴 객체 리스트 C를 정렬하는 것.(백준 11650번 문제)
c는 object로 임의 지정.
'''
```

## 백준 14889번 문제<br>
- Silver II 난이도의 백트래킹 문제입니다. 처음 짠 알고리즘에서 점수를 구하는 부분이 비효율적인줄 알고 2시간을 투자했으나, backtracking 하는 부분이 비효율적이었다는 사실에 심히 통탄하고 이렇게 적습니다..
```python
import sys

MIN_DIF = 999

def backtracking(start_idx, cnt):
    if cnt == N/2:
        global MIN_DIF
        team_start = 0
        team_link = 0

        '''
        처음에 이 부분에서 시간을 많이 잡아먹는 줄 알고 O(N^2)를 줄이고자 2시간을 투자하였다.
        하지만 그 어떤 방식으로도 해결할 수 없었다.
        '''
        for i in range(N-1):
            for j in range(i+1, N):
                if checking[i] and checking[j]:
                    team_start += team[i][j] + team[j][i] # lst[lst_[i]] 꼴의 참조는 시간을 더 잡아먹는다고 한다.
                elif not checking[i] and not checking[j]:
                    team_link += team[i][j] + team[j][i]

        dif = abs(team_start - team_link)
        MIN_DIF = min(MIN_DIF, dif)
        return

    '''
    해당 부분에서 continue를 통해 backtracking을 하면 비효율적이다.
        - 아래 구문을 사용했을 때 '시간 초과' 발생
            for i in range(N):
                if checking[i]:
                    continue 
    start_idx 변수를 통해 경우의 수를 최대한 줄여주자.
    '''
    for i in range(start_idx, N):
        checking[i] = 1
        backtracking(i + 1, cnt + 1)
        checking[i] = 0

N = int(sys.stdin.readline())
team = [list(map(int, sys.stdin.readline().split())) for _ in range(N)]

checking = [0] * N
backtracking(0, 0)

print(MIN_DIF)

```