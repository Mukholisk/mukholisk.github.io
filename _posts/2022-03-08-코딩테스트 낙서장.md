---
layout: post
title: 코딩테스트 낙서장
date: 2022-03-08 18:24 +0000
last_modified_at: 2022-06-12 23:54:13 +0000
tags: [코딩테스트, Python]
toc:  true
---

원래 C++로 준비했었으나, 새로운 마음으로 준비하기 위해 Python으로 갈아탔습니다.<br>
코딩테스트 준비 과정에서 문법적, 테크닉적으로 필요하겠다 싶은 것들을 기록하는 글입니다.<br><br>

## 이차원 리스트
```python
# 0으로 초기화된 N*M 리스트 선언
lst = [
    [0 for _ in range(M)]
    for _ in range(N)
]
```

## input() -> sys.stdin.readline()<br>
- ``sys.stdin.readline()``의 입력 처리 속도가 더 빠릅니다.
```python
import sys
n = int(sys.stdin.readline())
```

## map<br>
- 동시에 여러 값을 입력받기 위해 사용합니다.
```python
x, y = tuple(map(int, input().split())) # x, y
lst = map(int, input().split()) # lst
lst2 = map(int, sys.stdin.readline().split())
# sys.stdin.readline().strip(): readline()은 문자열 뒤에 개행문자가 붙는데, 이를 제거하는 함수이다.
```

## 최빈값 구하기<br>
```python
from collections import Counter
...
mod = Counter(lst).most_common(n) # n 생략시 1
# [(idx1, mod1), (idx2, mod2)] 꼴로 return 됨.
```

## 문자열<->리스트<br>
- 문자열에 sort함수를 사용하는 등의 경우에 사용합니다.

```python
import sys

N = sys.stdin.readline()
temp = list(N)
temp.sort(reverse=True)
N = ''.join(temp)

print(N)

```

## 객체 리스트 정렬시 다중 조건 적용하기<br>
```python
C.sort(key=lambda c: (c.x, c.y))
'''
x와 y를 멤버 변수로 가지는 Coordinate 클래스가 담긴 객체 리스트 C를 정렬하는 것.(백준 11650번 문제)
c는 object로 임의 지정.
'''
```

## 백준 14889번 문제<br>
- Silver II 난이도의 백트래킹 문제입니다. 처음 짠 알고리즘에서 점수를 구하는 부분이 비효율적인줄 알고 2시간을 투자했으나, backtracking 하는 부분이 비효율적이었다는 사실에 심히 통탄하고 이렇게 적습니다..<br>

```python
import sys

MIN_DIF = 999

def backtracking(start_idx, cnt):
    if cnt == N/2:
        global MIN_DIF
        team_start = 0
        team_link = 0

        '''
        처음에 이 부분에서 시간을 많이 잡아먹는 줄 알고 O(N^2)를 줄이고자 2시간을 투자하였다.
        하지만 그 어떤 방식으로도 해결할 수 없었다.
        '''
        for i in range(N-1):
            for j in range(i+1, N):
                if checking[i] and checking[j]:
                    team_start += team[i][j] + team[j][i] # lst[lst_[i]] 꼴의 참조는 시간을 더 잡아먹는다고 한다.
                elif not checking[i] and not checking[j]:
                    team_link += team[i][j] + team[j][i]

        dif = abs(team_start - team_link)
        MIN_DIF = min(MIN_DIF, dif)
        return

    '''
    해당 부분에서 continue를 통해 backtracking을 하면 비효율적이다.
        - 아래 구문을 사용했을 때 '시간 초과' 발생
            for i in range(N):
                if checking[i]:
                    continue 
    start_idx 변수를 통해 경우의 수를 최대한 줄여주자.
    '''
    for i in range(start_idx, N):
        checking[i] = 1
        backtracking(i + 1, cnt + 1)
        checking[i] = 0

N = int(sys.stdin.readline())
team = [list(map(int, sys.stdin.readline().split())) for _ in range(N)]

checking = [0] * N
backtracking(0, 0)

print(MIN_DIF)

```

## 백준 15663번 문제<br>
- Silver II의 백트래킹 문제입니다. 기존 값을 저장하기 위해 global list에 deepcopy를 사용해보았습니다.

```python
import sys

BEFORE = []
RESULT = []

def backtracking(idx):
    global BEROFE
    if idx == M:
        if RESULT not in BEFORE:
            BEFORE.append(RESULT[:]) # BEFORE는 지워지면 안되므로 deepcopy
            output = " ".join(RESULT)
            print(output)
        return
    
    for i in range(idx, N):
        RESULT.append(str(lst[i]))
        backtracking(idx+1)
        RESULT.pop()

N, M = tuple(map(int, sys.stdin.readline().split()))
lst = list(map(int, sys.stdin.readline().split()))
lst.sort()

backtracking(0)

```

## 백준 15663번 문제<br>
- Silver II 백트래킹 문제입니다. N과 M 시리즈 중에서 2번째로 정답 비율이 낮은 문제입니다. 주어진 N개의 자연수 중에서 M개를 고른 수열을 구하면 되는데 중복되는 수열은 한 번만 출력해야 합니다. 처음 시도했던 방법은 일일히 수열을 구해 RESULT 리스트에 없으면 저장하고, 모든 경우의 수를 다 구한 후 출력하는 방식이었는데 시간초과가 났습니다.
- 이후 backtracking 함수 내부의 for문에서 checking[i]가 직전 숫자와 같다면 거르는 구문을 추가하고, RESULT 리스트에 추가하는게 아닌 바로 출력하는 방식으로 고쳤더니 통과되었습니다.
- 문제를 풀다 집중력이 떨어져 쓸 데 없는 경우의 수 까지 고려해, 쉽게 갈 수 있던 문제를 빙빙 돌아온 것 같습니다. 

```python
import sys

RESULT = []

def backtracking(cnt):
    if cnt == M:
        print(" ".join(RESULT))
        return

    prev_num = -1
    for i in range(N):
        if checking[i] == 0 and prev_num != lst[i]:
            RESULT[cnt] = str(lst[i])
            checking[i] = 1
            backtracking(cnt+1)
            prev_num = lst[i]
            checking[i] = 0

N, M = tuple(map(int, sys.stdin.readline().split()))
lst = list(map(int, sys.stdin.readline().split()))
lst.sort()
checking = [0] * 10001
RESULT = [-2] * M

backtracking(0)

```

## 2차원 리스트 슬라이싱<br>

```python
temp = [row[c:c+j] for row in lst[r:r+i]]
```

## 리스트에서 값의 위치 찾기, 삽입하기, 삭제하기<br>

```python
# 리스트: lst, 값: city

# 특정 값의 위치 찾기
idx = lst.index(city)

# 삽입 1
lst.append(city) # 마지막 위치에 삽입

# 삽입 2
lst.insert(idx, city) # 해당 위치에 값 삽입


# 삭제 1(마지막 값)
lst.pop()

# 삭제 2(값 이용)
lst.remove(city)

# 삭제 3(위치 이용)
del lst[idx]
```

## Stack<br>
- 스택이 따로 없기 때문에 리스트를 사용한다.

```python
stack = []

# Push
stack.append(x)

# Pop
stack.pop()

# Top
stack[-1]

# Size
len(stack)

# Empty
False if len(stack) else True # True if len(stack) > 0 else False
```

## 백준 1038번 문제<br>

```python
'''
백준 1038번 문제
Gold V, Backtracking + Brute force

처음엔 Brute force로 풀어보았으나, 역시 재귀의 깊이가 깊어져 오류가 발생했다.

1. 생각을 해보면 조건에 맞는 숫자들 중 가장 큰 숫자는 9876543210이다.
2. 그렇다면 0부터 9까지의 숫자들로 1~10자리의 조합을 만들어서 리스트에 저장하면 N번째 숫자가 무엇인지 알 수 있지 않을까?
3. 조합은 [0] [1] [2] [3] [4] [5] [6] [7] [8] [9] [01] [02] [03] ... 꼴로 만들어진다.
4. 따라서 만들어진 조합을 내림차순으로 정렬해서 문자열로 변환한 것을 정수형으로 변환해 리스트에 저장하면 되지 않을까?
5. 리스트 요소들을 문자열로 만들기 위해서는 리스트 요소들이 '문자열'이어야 한다. 하지만 리스트의 요소들은 정수형이다.
6. 따라서 우선 리스트 요소들을 문자열로 변환하기 위해 map함수를 이용해 리스트의 요소들을 문자열로 바꿔줘야 한다.
7. 그것을 정수형으로 변환해 리스트에 저장하자.
8. N은 1부터 1,000,000까지 주어진다. 리스트에 N으로 접근해서 N번째 숫자가 있다면 결과값이 return될 것이고, N번째 숫자가 없다면 index error가 발생할 것이다.
9. 그렇다면 일단 리스트의 N번째 요소를 부르자. 예외처리를 사용하면 값이 없을 때 index error가 발생해 예외처리 구문이 실행될 것이다.

itertools로 조합을 만들어 내림차순으로 정렬하면 감소하는 숫자가 만들어진다.
그것을 number list에 저장 후, 오름차순으로 정렬하면 우리가 문제를 푸는데 필요한 list가 만들어진다.
map(function, iterable): iterable(list 등)을 function 함수를 적용해 return.
    map(str, lst) = lst의 요소들을 string화 시킨 list가 return된다.
'''
from itertools import combinations
import sys
input = sys.stdin.readline

N = int(input())

numbers = list()
for i in range(1, 11):
    for combi in combinations(range(0, 10), i):
        combi = list(combi)
        combi.sort(reverse=True)
        numbers.append(int("".join(map(str, combi))))

numbers.sort()

try:
    print(numbers[N])
except:
    print(-1)
```

## Counter<br>
- 문자열의 갯수를 세는 방법은 dictionary를 사용하는 방법도 있지만, Counter 라이브러리를 사용할 수도 있습니다. ``Counter(문자열).most_common(1)``[0]의 [0]은 글자, [1]은 글자수 입니다.

```python
from collections import Counter

str = "MyLifeWouldSuckWithOut You"

# Use Dictionary
str.lower()
counter = {}
for s in str:
    if s not in counter:
        counter[s] = 0
    counter[s] += 1

print(counter)
print()

# Use Counter
cntr = Counter(str) # 자동 정렬되어 제공됨
print(cntr) # SET로 return
print(cntr.most_common()) # SET
print(cntr.most_common(1)) # SET를 LIST로 return
print(cntr.most_common(1)[0][0])
print(cntr.most_common(1)[0][1])

```

## Set Recursion Limit<br>
- 파이썬으로 DFS 등 재귀를 사용하는 문제를 풀다보면 재귀의 깊이가 깊어져 오류가 나는 경우가 있습니다. 파이썬의 재귀 깊이 제한은 1000인데, 이것을 풀 수 있는 방법이 있습니다.

```python
import sys
sys.setrecursionlimit(10000)

```

## 프로그래머스 코딩테스트 연습 > 깊이/너비 우선 탐색(DFS/BFS) > 여행경로<br>
- level 3의 DFS/BFS 문제입니다. 코드의 주석에 문제를 풀던 과정이 기재되어 있습니다. 코드를 덧붙이고 덧붙이다보니 조금 복잡해진 것 같은데, 처음부터 counting dictionary를 사용했다면 조금 더 깔끔한 코드가 되었을 것 같아 아쉽습니다.

```python
'''
https://programmers.co.kr/learn/courses/30/lessons/43164

DFS/BFS 문제.
출발지를 key로, 도착지를 value의 list로 하는 dictionary, 중복표를 위한 counting dictionary를 사용함.
Hash의 key로 변할 수 있는 값을 사용할 수 없기 때문에 tuple로 바꾸어 줌.

1. 백트래킹을 제대로 하지 못함(1, 2? 4? 오류) -> 해결
2. 표가 중복인 경우를 찾지 못함 -> counting dictionary를 추가 -> (1 오류)
3. 문제의 조건이 잘못되었다? -> 그건 잘 모르겠고 문제 설명이 조금은 불친절하긴 하다.
4. 왜 ICN이 처음에 없는가?(이거다) -> DFS 내부 로직에 문제가 있다.
    -> 중복을 고려하면서 (앞에서부터 지우는) remove를 사용했던게 문제 -> 아니 애초에 pop을 썼으면 됐잖아 DFS는 STACK이라고 STACK!
'''

answer = []
custom_tickets = {}
ticket_counting = {}

def DFS(ticket, used_tickets, tickets, used_counting):
    global answer, custom_tickets, ticket_counting
    if len(used_tickets) == len(tickets):
        temp = [used_tickets[0][0]]
        for i in range(len(used_tickets)):
            temp.append(used_tickets[i][1])
        answer.append(temp[:])
        return

    # 예외처리
    if ticket[1] not in custom_tickets:
        return

    for dest in custom_tickets[ticket[1]]:
        next_ticket = (ticket[1], dest)
        if used_counting[next_ticket] < ticket_counting[next_ticket]:
            used_tickets.append(next_ticket)
            used_counting[next_ticket] += 1
            DFS(next_ticket, used_tickets, tickets, used_counting)
            # used_counting.remove(next_ticket)
            used_tickets.pop()
            used_counting[next_ticket] -= 1
    

def solution(tickets):
    global answer, ticket_counting
    used_tickets = []
    used_counting = {}
    
    # Preprocessing
    for ticket in tickets:
        if ticket[0] not in custom_tickets:
            custom_tickets[ticket[0]] = list()
        custom_tickets[ticket[0]].append(ticket[1])

        if tuple(ticket) not in ticket_counting:
            ticket_counting[tuple(ticket)] = 0
            used_counting[tuple(ticket)] = 0
        ticket_counting[tuple(ticket)] += 1
        
    # Processing
    for dest in custom_tickets['ICN']:
        ticket = ('ICN', dest)
        if used_counting[ticket] < ticket_counting[ticket]:
            used_tickets.append(ticket)
            used_counting[ticket] += 1
            DFS(ticket, used_tickets, tickets, used_counting)
            # used_tickets.remove(ticket)
            used_tickets.pop()
            used_counting[ticket] -= 1

    answer.sort()
    answer = answer[0]
    return answer

tickets = [["ICN","A"],['ICN', 'B'], ['B','ICN']]
answer = solution(tickets)
print(answer)

```

## 프로그래머스 코딩테스트 연습 > 탐욕법(Greedy) > 큰 수 만들기<br>
- level 2의 탐욕법(Greedy) 문제입니다. 문제의 방향을 잡지 못했으나, 그 과정이 주석의 참조1 링크의 내용과 같아 참조했습니다.

```python
'''
문제: https://programmers.co.kr/learn/courses/30/lessons/42883
참조1: https://velog.io/@soo5717/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%ED%81%B0-%EC%88%98-%EB%A7%8C%EB%93%A4%EA%B8%B0-%ED%8C%8C%EC%9D%B4%EC%8D%AC
참조2: https://programmers.co.kr/questions/25858

-> 탐욕법이나 DP나 이론만 대충 알고있었는데, 막상 코드를 짜보니 막막하다.
'''
def solution(number, k):
    stack = []
    
    # 앞에서부터, 뒷 숫자보다 작으면 총 k개 삭제하는 알고리즘
    for n in number:
        if not len(stack):
            stack.append(n)
        else:
            if k > 0:
                while stack[-1] < n:
                    stack.pop()
                    k -= 1
                    # 앞의 숫자를 다 지운 경우 // 총 개수를 다 지운 경우(하단 else)
                    if not len(stack) or k <= 0:
                        break
            stack.append(n)

    # if문의 경우, 앞의 숫자를 다 지웠으나 k개 만큼 지우지 못했다면 맨 뒷쪽에서 남은 갯수만큼 지워주면 된다.
    stack = stack[:-k] if k > 0 else stack
    return ''.join(stack)

number = "654321"
k = 1
answer = solution(number, k)
print(answer)

```

## 프로그래머스 > 코딩테스트 연습 > 그래프 > 가장 먼 노드(Level 3)<br>
- 최초 실행 코드에서 custom의 사이즈를 줄여 해결했습니다. 하단의 기존 코드에서는 custom을 n+1만큼 선언하고 BFS애서 반복문을 N만큼 돌렸는데, 통과 코드에서는 custom을 edge 수만큼 append 연산을 해주고 BFS에서 해당 edge의 수만큼만 반복문을 돌렸습니다. 이 차이가 7~9번 테스트 케이스의 시간 초과를 해결해준 것 같습니다.<br>
- 잘은 모르겠으나, 통과 코드가 다익스트라 알고리즘과 유사해보입니다.

```python
'''
https://programmers.co.kr/learn/courses/30/lessons/49189

TMI: 코드 분석(solution)
    - 기존 코드: O(N) + O(N) = 2N = N
    - 통과 코드: O(N log N) + O(1) = N log N + 1 = N log N
-> sort보다는 원래 쓰던 max + count 조합을 쓰자.
'''
# 통과 코드
from queue import Queue
q = Queue()

def BFS(custom, node, n):
    q.put(n)

    while not q.empty():
        curnode = q.get()

        for e in custom[curnode]:
            if node[curnode]+1 < node[e]: # 해당 경우를 만족하지 않으면 1에서 최단거리로 가는 경우가 아님
                q.put(e)
                node[e] = node[curnode]+1

def solution(n, vertex):
    # Graph
    custom = [[] for _ in range(n+1)]

    for v in vertex:
        s, e = v[0], v[1]
        custom[s].append(e)
        custom[e].append(s)
    
    # 노드별 최단 거리 저장
    node = [55555] * (n+1)
    node[0] = 0 # reset
    node[1] = 1 # 시작점
    BFS(custom, node, 1)

    node.sort()
    k = node.index(node[-1])
    answer = n+1-k

    return answer

n = 6
vertex = [[3, 6], [4, 3], [3, 2], [1, 3], [1, 2], [2, 4], [5, 2]]
answer = solution(n, vertex)
print(answer)

'''
# 최초 코드(TC 7~9에서 시간초과)
from queue import Queue
q = Queue()

def BFS(custom, node, n):
    q.put(n)

    while not q.empty():
        curnode = q.get()

        for i in range(1, len(custom)):
            if curnode == i:
                continue
            if custom[curnode][i] == 1:
                if node[curnode]+1 < node[i]: # 해당 경우를 만족하지 않으면 1에서 최단거리로 가는 경우가 아님
                    q.put(i)
                    node[i] = node[curnode]+1

def solution(n, vertex):
    # Graph
    custom = [
        [0 for _ in range(n+1)]
        for _ in range(n+1)
    ]

    for v in vertex:
        s, e = v[0], v[1]
        custom[s][e] = 1
        custom[e][s] = 1
    
    # 노드별 최단 거리 저장
    node = [55555] * (n+1)
    node[0] = 0 # reset
    node[1] = 1 # 시작점
    BFS(custom, node, 1)

    maxnum = max(node)
    answer = node.count(maxnum)

    return answer

n = 6
vertex = [[3, 6], [4, 3], [3, 2], [1, 3], [1, 2], [2, 4], [5, 2]]
answer = solution(n, vertex)
print(answer)
'''
```

## 다익스트라 알고리즘(Dijkstra Algorithm)<br>
- 다익스트라 알고리즘은 다이나믹 프로그래밍(Dynamic Programming)을 활용한 최단 경로(Shortest Path) 탐색 알고리즘입니다. '특정 정점에서 다른 모든 정점'로 가는 최단 경로를 계산합니다. 단, 다익스트라 알고리즘은 음의 간선을 적용할 수 없어 음의 간선이 없는 현실 세계에 사용하기 매우 적합한 알고리즘입니다. 해당 알고리즘을 대입한 문제가 바로 위에 있는 '가장 먼 노드' 문제이기도 합니다. -> 해당 문제는 가중치가 모두 1인 경우라 BFS로 풀어도 무관하지만, 가중치가 있다면 무조건 다익스트라 알고리즘을 사용해야합니다. ![참고 블로그](https://blog.naver.com/ndb796/221234424646)
- 최단 거리는 여러 개의 최단 거리로 이루어져 있기 때문에 작은 문제가 큰 문제의 부분 집합에 속해있다고 볼 수 있으며, 하나의 최단 거리를 구할 때 그 이전까지 구했던 최단 거리 정보를 그대로 이용합니다. 따라서 다익스트라 알고리즘은 다이나믹 프로그래밍 문제이기도 합니다.

```python
for e in range(n):
    if not visited[e]:
        if d[cur]+graph[cur][e] < d[e]:
            d[e] = d[cur] + graph[cur][e]
```

## 플로이드 와샬 알고리즘(Floyd Warshall Algorithm)<br>
- 플로이드 와샬 알고리즘은 '모든 정점에서 모든 정점'으로의 최단 경로를 구하는 알고리즘입니다. 다익스트라 알고리즘은 가장 적은 비용을 하나씩 선택했지만 플로이드 와샬 알고리즘은 '거쳐가는 정점'을 기준으로 수행됩니다. 또한, 플로이드 와샬 알고리즘 역시도 다이나믹 프로그래밍을 활용합니다. ![참고 블로그](https://blog.naver.com/ndb796/221234427842)
- 사담)그래프의 경우 간선의 방향성이 있는지 없는지, 가중치가 있는지 없는지에 따라 구현부의 코드가 조금씩 달라지지만 큰 틀을 벗어나지는 않는듯 하네요.
- 알고리즘은 간단하게 A to B의 최소 비용 vs. A to C + C to B의 최소 비용의 비교입니다. 3중 for문으로 구현하는 방식이 있습니다.

```python
for m in range(n): # 거쳐가는 노드
    for s in range(n): # 출발 노드
        for e in range(n): # 도착 노드
            if d[s][m] + d[m][e] < d[s][e]: # 경유 거리가 직행 거리(초기)/최단 거리(갱신 후)보다 짧은 경우
                d[s][e] = d[s][m] + d[m][e] # 최단 거리 갱신
```
