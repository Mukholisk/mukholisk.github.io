---
layout: post
title: 취약 개념 보충
date: 2022-06-02 02:09 +0000
last_modified_at: 2022-06-02 17:11:55 +0000
tags: [코딩테스트]
toc:  true
---

중간중간 소홀했지만 그래도 조금씩이나마 무언갈 하고 있었습니다.<br>
프로그래밍 경시대회나 여타 문제들을 풀면서 일부 개념을 문제에 적용하지 못하는 경우가 있어 그 경우를 정리하고자 합니다.<br>

## Hash<br>
해쉬(Hash)는 임의의 크기를 가진 데이터를 고정된 데이터의 크기로 변환시키는 것을 말합니다. 특정한 배열의 인덱스나 위치를 입력하고자 하는 데이터의 값을 이용해 저장하거나 찾을 수 있습니다. 해쉬의 경우 대부분의 연산에서 시간복잡도 O(1)을 가집니다. 따라서 데이터를 삽입, 삭제, 검색하는 일이 많은 경우 이를 사용해야 합니다.<br>
파이썬에서는 Dictionary를 통해 해쉬를 사용할 수 있습니다.

```python
# 빈 딕셔너리
dict1 = {}
dict2 = dict()

# 데이터가 들어있는 딕셔너리
User = {
    'ID' : 'Mukho'
    'Line' : 'Support'
}
Users = {
    'LOL' : {'ID' : 'Mukho', 'Line' : 'Support'},
    'Kart' : {'ID' : '97lineMusic', 'Position' : 'Runner'}
}

# 삽입, 삭제, 수정, 검색
User['Top_Rating'] = 'D2'
del User['Top_Rating']
User['Line'] = 'AD Carry'
User.get('ID', 'no') # User 딕셔너리에서 Key가 'ID'인 Value를 가져와라. 단, 없을 경우 'no'를 반환한다.

# 출력
for key in dict:
    print(key) # key값만 출력됨
    print(dict[key]) # value값이 출력됨
for k in dict.keys():
    print(k)
for v in dict.values():
    print(v)
for k, v in dict.items():
    print(k, v)
```

## 조합(Combinations), 순열(Permutations)<br>
조합(combination)은 n개의 원소를 갖는 집합에서 r개의 원소를 선택하는 것으로, 순서는 중요하지 않습니다.<br>
순열(permutation)은 n개의 원소에서 순서에 유의하여 r개를 나열하는 것입니다.<br>
조합과 순열은 기본적으로 중복을 허용하지 않습니다만, 경우에 따라서 중복을 허용해야 하는 경우가 있습니다.<br>
조합과 순열은 backtracking을 통해 만들 수 있으나, python에는 itertools라는 라이브러리가 있어 이를 이용해 편하게 만들 수 있습니다.<br>

```python
# 조합 및 중복조합
from itertools import combinations, combinations_with_replacement

lst = [1, 2, 3]

# 조합
print('---조합---')
for i in range(1, 4):
    for combi in combinations(lst, i):
        combi = list(combi)
        print(combi)

# 중복조합(자기 자신의 중복을 허용. 단, 순서만 다른 case는 배제)
print('---중복조합---')
for i in range(1, 4):
    for combi in combinations_with_replacement(lst, i):
        combi = list(combi)
        print(combi)

'''
---조합---
[1]
[2]
[3]
[1, 2]
[1, 3]
[2, 3]
[1, 2, 3]
---중복조합---
[1]
[2]
[3]
[1, 1]
[1, 2]
[1, 3]
[2, 2]
[2, 3]
[3, 3]
[1, 1, 1]
[1, 1, 2]
[1, 1, 3]
[1, 2, 2]
[1, 2, 3]
[1, 3, 3]
[2, 2, 2]
[2, 2, 3]
[2, 3, 3]
[3, 3, 3]
'''
```
```python
# 순열과 중복순열
from itertools import permutations, product

lst = [1, 2, 3]

# 순열
print('---순열---')
for i in range(1, 4):
    for permu in permutations(lst, i):
        permu = list(permu)
        print(permu)

# 중복순열
print('---중복순열---')
for i in range(1, 4):
    for prod in product(lst, repeat=i):
        prod = list(prod)
        print(prod)

'''
---순열---
[1]
[2]
[3]
[1, 2]
[1, 3]
[2, 1]
[2, 3]
[3, 1]
[3, 2]
[1, 2, 3]
[1, 3, 2]
[2, 1, 3]
[2, 3, 1]
[3, 1, 2]
[3, 2, 1]
---중복순열---
[1]
[2]
[3]
[1, 1]
[1, 2]
[1, 3]
[2, 1]
[2, 2]
[2, 3]
[3, 1]
[3, 2]
[3, 3]
[1, 1, 1]
[1, 1, 2]
[1, 1, 3]
[1, 2, 1]
[1, 2, 2]
[1, 2, 3]
[1, 3, 1]
[1, 3, 2]
[1, 3, 3]
[2, 1, 1]
[2, 1, 2]
[2, 1, 3]
[2, 2, 1]
[2, 2, 2]
[2, 2, 3]
[2, 3, 1]
[2, 3, 2]
[2, 3, 3]
[3, 1, 1]
[3, 1, 2]
[3, 1, 3]
[3, 2, 1]
[3, 2, 2]
[3, 2, 3]
[3, 3, 1]
[3, 3, 2]
[3, 3, 3]
'''

```

## Backtracking<br>
백트래킹은 모든 경우의 수를 전부 고려하는 알고리즘입니다. 트리 탐색 알고리즘의 일종이며 깊이 우선 탐색(DFS: Depth First Search), 너비 우선 탐색(BFS: Breadth First Search), 최선 우선 탐색(Best First Search/Heuristic Search) 등이 있습니다.<br>
보통 모든 경우의 수를 고려해야 하는 문제라면 DFS가 낫지만, 최단거리 구하기 등 트리의 깊이가 무한대가 되는 경우에는 Queue를 이용한 BFS를 사용하는 것이 낫습니다.

## DFS, BFS<br>
DFS는 상태공간을 나하낸 트리에서 바닥에 도달할 때까지 한 쪽 방향으로만 내려가는 방식입니다. 재귀함수나 스택으로 구현할 수 있습니다.<br>
BFS는 모든 분기점을 다 검사하면서 진행하는 방식입니다. BFS에서는 queue를 사용하여 구현하며, 각 경우를 검사하면서 발생하는 새로운 경우를 queue에 집어넣고, 검사한 경우는 queue에서 빼는 순으로 진행합니다.<br>
얼마 전에 한 알고리즘 문제를 DFS와 BFS 두 방법으로 풀어보았습니다.<br>
하단의 코드에서 ``sys.setrecursionlimit()``은 파이썬의 재귀 깊이 default 값인 1000을 확장하기 위한 방법입니다.<br>

```python
'''
백준 2468번: 안전 영역(Silver I)
개념: 그래프 이론/탐색, 브루트포스, DFS, BFS
https://www.acmicpc.net/problem/2468
'''

import sys
from queue import Queue
sys.setrecursionlimit(10000)

# U, D, L, R
dx = [+0, +0, -1, +1]
dy = [-1, +1, +0, +0]

def in_range(x, y):
    return 0 <= x and x < N and 0 <= y and y < N

def DFS(x, y, n):
    # move
    for i in range(4):
        nx = x + dx[i]
        ny = y + dy[i]

        if in_range(nx, ny) and visited[nx][ny] == 0 and local[nx][ny] > n:
            # check
            visited[nx][ny] = 1
            DFS(nx, ny, n)

def BFS(x, y, n):
    q = Queue()
    q.put([x, y])

    while not q.empty():
        cx, cy = q.get()
        # move
        for i in range(4):
            nx = cx + dx[i]
            ny = cy + dy[i]

            if in_range(nx, ny) and visited[nx][ny] == 0 and local[nx][ny] > n:
                # check
                visited[nx][ny] = 1
                q.put([nx, ny])

answer = 1
N = int(input())

in_min = 101
in_max = 0
local = []
for _ in range(N):
    in_row = list(map(int, input().split()))
    local.append(in_row)

    in_min = min(min(in_row), in_min)
    in_max = max(max(in_row), in_max)

for n in range(in_min, in_max):
    visited = [
        [0 for _ in range(N)]
        for _ in range(N)
    ]
    
    cnt = 0
    for i in range(N):
        for j in range(N):
            if local[i][j] > n and visited[i][j] == 0:
                visited[i][j] = 1
                cnt += 1
                #DFS(i, j, n)
                BFS(i, j, n)
    answer = max(answer, cnt)

print(answer)

```

## 트리(Tree)<br>

## 동적 계획법(Dynamic Programming<br>
